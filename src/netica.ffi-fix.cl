;;; Fix missing pieces in SWIG auto generated wrapper

(in-package :netica.ffi)


(define-symbol-macro *undef-dbl* (get-undef-dbl-ns))
(define-symbol-macro *infinity-ns* (get-infinity-dbl-ns))

(swig-defun ("GetNeticaVersion_bn" "GetNeticaVersion_bn")
            ((:p+ PARM0_env  (* #.(swig-insert-id "__SWIGACL_FwdReference" () :type :type)) )
             (:p- PARM1_version  (* (* :char)) ))
            (:returning (:int )
             :strings-convert t)
  (cl::let ((ACL_ffresult swig:*void*)
            ACL_result)
    (cl::let ((SWIG_arg0 PARM0_env))
      (cl::let ((SWIG_arg1 (ff:allocate-fobject '(* :char) :c)))
        (cl::setq ACL_ffresult (swig-ff-call SWIG_arg0 SWIG_arg1))
        (cl::push (excl:native-to-string (ff:fslot-value-typed '(* :char) :c SWIG_arg1)) ACL_result)
        (ff:free-fobject SWIG_arg1)) )
    (cl::if (cl::eq ACL_ffresult swig:*void*)
            (cl::values-list ACL_result)
            (cl::values-list (cl::cons ACL_ffresult ACL_result)))))

(swig-defun ("GetNetNthUserField_bn" "GetNetNthUserField_bn")
            ((:p+ PARM0_net  (* #.(swig-insert-id "__SWIGACL_FwdReference" () :type :type)) )
             (:p+ PARM1_index  :int )
             (:p- PARM2_name  (* (* :char)) )
             (:p- PARM3_value  (* (* :char)) )
             (:p- PARM4_length  (* :int) )
             (:p+ PARM5_kind  :int ))
            (:returning (:void )
             :strings-convert t)
  (cl::let ((ACL_ffresult swig:*void*)
            ACL_result)
    (cl::let ((SWIG_arg0 PARM0_net))
      (cl::let ((SWIG_arg1 PARM1_index))
        (cl::let ((SWIG_arg2 (ff:allocate-fobject '(* :char) :c)))
          (cl::let ((SWIG_arg3 (ff:allocate-fobject '(* :char) :c)))
            (cl::let ((SWIG_arg4 (ff:allocate-fobject ':int :c)))
              (cl::let ((SWIG_arg5 PARM5_kind))
                (swig-ff-call SWIG_arg0 SWIG_arg1 SWIG_arg2 SWIG_arg3 SWIG_arg4 SWIG_arg5))
              (cl::push (ff:fslot-value-typed (cl::quote :int) :c SWIG_arg4) ACL_result)
              (cl::push (excl:native-to-string (ff:fslot-value-typed '(* :char) :c SWIG_arg3)) ACL_result)
              (cl::push (excl:native-to-string (ff:fslot-value-typed '(* :char) :c SWIG_arg2)) ACL_result)
              (ff:free-fobject SWIG_arg2)
              (ff:free-fobject SWIG_arg3)
              (ff:free-fobject SWIG_arg4)) ))))
    (cl::if (cl::eq ACL_ffresult swig:*void*)
            (cl::values-list ACL_result)
            (cl::values-list (cl::cons ACL_ffresult ACL_result)))))

(swig-defun ("GetNodeNthUserField_bn" "GetNodeNthUserField_bn")
            ((:p+ PARM0_node  (* #.(swig-insert-id "__SWIGACL_FwdReference" () :type :type)) )
             (:p+ PARM1_index  :int )
             (:p- PARM2_name  (* (* :char)) )
             (:p- PARM3_value  (* (* :char)) )
             (:p- PARM4_length  (* :int) )
             (:p+ PARM5_kind  :int ))
            (:returning (:void )
             :strings-convert t)
  (cl::let ((ACL_ffresult swig:*void*)
            ACL_result)
    (cl::let ((SWIG_arg0 PARM0_node))
      (cl::let ((SWIG_arg1 PARM1_index))
        (cl::let ((SWIG_arg2 PARM2_name))
          (cl::let ((SWIG_arg3 PARM3_value))
            (cl::let ((SWIG_arg4 (ff:allocate-fobject ':int :c)))
              (cl::let ((SWIG_arg5 PARM5_kind))
                (swig-ff-call SWIG_arg0 SWIG_arg1 SWIG_arg2 SWIG_arg3 SWIG_arg4 SWIG_arg5))
              (cl::push (ff:fslot-value-typed (cl::quote :int) :c SWIG_arg4) ACL_result)
              (cl::push (excl:native-to-string (ff:fslot-value-typed '(* :char) :c SWIG_arg3)) ACL_result)
              (cl::push (excl:native-to-string (ff:fslot-value-typed '(* :char) :c SWIG_arg2)) ACL_result)
              (ff:free-fobject SWIG_arg2)
              (ff:free-fobject SWIG_arg3)
              (ff:free-fobject SWIG_arg4)) ))))
    (cl::if (cl::eq ACL_ffresult swig:*void*)
            (cl::values-list ACL_result)
            (cl::values-list (cl::cons ACL_ffresult ACL_result)))))

(defun report-junction-tree-bn (net)
  (create-custom-report-bn net *null* "[[Net.JunctionTreeTable(TextFormat)]]" *null*))
(eval-when (:compile-toplevel :load-toplevel :execute)
  (export 'report-junction-tree-bn))

(defun get-net-nodes-bn (net)
  (get-net-nodes2-bn net "incl_docn"))
(eval-when (:compile-toplevel :load-toplevel :execute)
  (export 'get-net-nodes-bn))
